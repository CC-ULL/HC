{"version":3,"sources":["components/SubmittableTextarea/index.tsx","lib/Edges.ts","lib/Node.ts","lib/vertexCoverInstanceParser.ts","lib/Graph.ts","lib/Edge.ts","lib/EdgeGadget.ts","components/Tabs/index.tsx","App.tsx","lib/transformation.ts","index.tsx"],"names":["State","textareaValue","SubmittableTextarea","state","onValueChange","_ref","target","_this","setState","value","onSubmit","props","react_default","a","createElement","className","this","onChange","rows","onClick","Component","DuplicateEdgeError","_Error","from","to","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","concat","inherits","wrapNativeSuper","Error","Symbol","iterator","Edges","_map","Map","_list","createClass","key","toIds","get","includes","push","set","_addSingleEdge","list","_Symbol$iterator","regenerator_default","mark","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_ref2","_from","_to","wrap","_context","prev","next","undefined","done","t0","return","finish","stop","Node","identifier","id","label","GroupedNode","group","x","y","SEPARATION_OFFSET","mapToGroupedNodes","nodes","groupId","result","halfLength","Math","floor","length","i","console","log","LINES_SEPARATOR","ELEMENTS_SEPARATOR","vertexCoverInstanceParser","rawRepr","lines","split","map","line","trim","filter","_lines","toArray","coverSizeRepr","nodesRepr","verticesRepr","slice","nodeSet","nodesReprs","str","Set","parseNodes","edgesMap","edges","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","vertexRepr","vertexElements","_vertexElements","slicedToArray","add","err","parseEdges","toConsumableArray","coverSize","parseInt","isNaN","parseCoverSize","invalidNode","has","size","graph","repr","Graph","newVertices","newEdges","Edge","EdgeGadget","leftVertexID","rightVertexID","vertices","edgeGadgetID","leftSideVertexID","isTopLeftVertexConnected","isBottomLeftVertexConnected","rightSideVertexID","isTopRightVertexConnected","isBottomRightVertexConnected","VERTEX_IN_EDGE_GADGET","edgeGadgets","vertexID","firstGadget","secondGadget","firstId","secondId","edgeGadget","selectors","connectionPoints","forEach","Tabs","currentTab","_this2","_this$props","tabNames","children","name","React","Children","child","index","hidden","PureComponent","graphOptions","layout","hierarchical","randomSeed","color","arrows","enabled","physics","App","instances","onNewProblemInstance","vcInstance","hcInstance","newGraph","addVertices","vertexAndEdgeGadgetsInfo","_ref3","newEdgeGadget","firstVertexEdgeGadgets","secondVertexEdgeGadgets","_ref4","addEdges","_ref5","connectEdgeGadgets","connectEdgeGadgetWithSelectors","transformation","vcGraph","hcGraph","error","src_components_SubmittableTextarea","Tabs_Tabs","lib_default","options","ReactDOM","render","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.7dd1a013.chunk.js","sourcesContent":["import React, { Component, ChangeEvent } from \"react\";\nimport \"./index.scss\";\n\ninterface Props {\n  /**\n   * Callback run whenever the user submits a new text\n   *\n   * @param value Text submitted by the user\n   * @returns Whether the textarea should be emptied or not\n   */\n  onSubmit: (value: string) => boolean;\n}\n\nclass State {\n  textareaValue: string = \"\";\n}\n\nclass SubmittableTextarea extends Component<Props, State> {\n  state = new State();\n\n  onValueChange = ({ target }: ChangeEvent<HTMLTextAreaElement>) => {\n    this.setState({\n      textareaValue: target.value\n    });\n  };\n\n  onSubmit = () => {\n    const clearTextarea = this.props.onSubmit(this.state.textareaValue);\n\n    if (clearTextarea) {\n      this.setState({\n        textareaValue: \"\"\n      });\n    }\n  };\n\n  render() {\n    return (\n      <div className=\"SubmittableTextarea\">\n        <textarea\n          className=\"SubmittableTextarea__textarea\"\n          value={this.state.textareaValue}\n          onChange={this.onValueChange}\n          rows={15}\n        />\n        <button\n          className=\"SubmittableTextarea__submit-button\"\n          onClick={this.onSubmit}\n        >\n          Submit\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default SubmittableTextarea;\n","import { IEdge } from \"./Edge\";\n\nexport class DuplicateEdgeError extends Error {\n  constructor(public from: string, public to: string) {\n    super(`Duplicate edge ${from} - ${to}`);\n  }\n}\n\nexport class Edges {\n  /** Keeps track of all the edges related to all the nodes */\n  private _map: Map<string, string[]> = new Map();\n\n  /** Keeps track of all the edges */\n  private _list: IEdge[] = [];\n\n  /** Adds the given edge to the map */\n  private _addSingleEdge(from: string, to: string) {\n    const toIds = this._map.get(from);\n\n    if (toIds) {\n      if (toIds.includes(to)) {\n        throw new DuplicateEdgeError(from, to);\n      }\n      toIds.push(to);\n    } else {\n      this._map.set(from, [to]);\n    }\n  }\n\n  /** Adds the given undirected edge */\n  public add(from: string, to: string) {\n    this._addSingleEdge(from, to);\n\n    if (from !== to) {\n      this._addSingleEdge(to, from);\n    }\n\n    this.list.push({ from, to });\n  }\n\n  /** Returns all edges coming from/to the given node ID */\n  public get(from: string): string[] | null {\n    return this._map.get(from) || null;\n  }\n\n  /** Returns the set of all the edges */\n  public get list(): IEdge[] {\n    return this._list;\n  }\n\n  /** Returns a iterator to go over the set of edges */\n  public *[Symbol.iterator]() {\n    for (const { from, to } of this.list) {\n      yield [from, to];\n    }\n  }\n}\n","export interface INode {\n  id: string;\n}\n\n/**\n * Class which represents a graph vertex\n */\nexport default class Node implements INode {\n  id: string;\n  label: string;\n\n  constructor(identifier: string) {\n    this.id = identifier;\n    this.label = identifier;\n  }\n}\n\nexport class GroupedNode implements INode {\n  public id: string;\n  public label: string;\n  public group: number;\n  public x: number;\n  public y: number;\n\n  constructor(id: string, group: number, x: number, y: number) {\n    this.id = id;\n    this.label = id;\n    this.x = x;\n    this.y = y;\n    this.group = group;\n  }\n}\n\nconst SEPARATION_OFFSET = 100;\n\nexport function mapToGroupedNodes(\n  nodes: INode[],\n  groupId: number\n): GroupedNode[] {\n  const result: GroupedNode[] = [];\n  const halfLength = Math.floor(nodes.length / 2);\n\n  for (let i = 1; i <= halfLength; ++i) {\n    console.log({ i });\n    result.push(\n      new GroupedNode(\n        nodes[i - 1].id,\n        groupId,\n        SEPARATION_OFFSET * groupId,\n        SEPARATION_OFFSET * i\n      )\n    );\n  }\n\n  for (let i = 1 + halfLength; i <= nodes.length; ++i) {\n    console.log({ i });\n    result.push(\n      new GroupedNode(\n        nodes[i - 1].id,\n        groupId,\n        SEPARATION_OFFSET * (groupId + 1),\n        SEPARATION_OFFSET * (i - halfLength)\n      )\n    );\n  }\n\n  return result;\n}\n","import { Edges } from \"./Edges\";\nimport { IEdge } from \"./Edge\";\nimport { IVertexCoverInstance } from \"./IVertexCoverInstance\";\nimport Node from \"./Node\";\n\n// TODO: Create better classes for errors\n\nconst LINES_SEPARATOR = \"\\n\";\nconst ELEMENTS_SEPARATOR = \",\";\n\nexport function vertexCoverInstanceParser(\n  rawRepr: string\n): IVertexCoverInstance {\n  const lines = rawRepr\n    .split(LINES_SEPARATOR)\n    .map(line => line.trim())\n    .filter(line => line !== \"\");\n\n  // Check that there is at least the minimum number of elements required\n  if (lines.length < 2) {\n    throw new Error(\n      \"Invalid number of elements. Must contain cover size, node set & vertex set\"\n    );\n  }\n\n  const [coverSizeRepr, nodesRepr, ...verticesRepr] = lines;\n  const nodeSet = parseNodes(nodesRepr);\n  const edgesMap = parseEdges(verticesRepr);\n  const edges = [...edgesMap.list];\n  const coverSize = parseCoverSize(coverSizeRepr);\n\n  // Check that all edges are from valid nodes to valid nodes\n  let invalidNode = null;\n  for (const { from, to } of edges) {\n    if (!nodeSet.has(from)) {\n      invalidNode = from;\n    } else if (!nodeSet.has(to)) {\n      invalidNode = to;\n    }\n\n    if (invalidNode !== null) {\n      throw new Error(\n        `${invalidNode} is not a valid node in edge ${from} - ${to}`\n      );\n    }\n  }\n\n  // Check that the cover size is plausible\n  if (coverSize < 1 || coverSize > nodeSet.size) {\n    throw new Error(\n      `Invalid cover size. Must be between 1 and ${\n        nodeSet.size\n      } (size of the set of nodes)`\n    );\n  }\n\n  return {\n    coverSize,\n    graph: {\n      nodes: [...nodeSet].map(repr => new Node(repr)),\n      edges\n    }\n  };\n}\n\nexport function parseNodes(nodesRepr: string): Set<string> {\n  const nodesReprs = nodesRepr.split(ELEMENTS_SEPARATOR).map(str => str.trim());\n\n  return new Set(nodesReprs);\n}\n\nexport function parseEdges(verticesRepr: string[]): Edges {\n  const edges = new Edges();\n\n  for (const vertexRepr of verticesRepr) {\n    const vertexElements = vertexRepr.split(ELEMENTS_SEPARATOR);\n\n    if (vertexElements.length !== 2) {\n      throw new Error(\n        `Invalid vertex \"${vertexRepr}\". Vertices must contain exactly two nodes`\n      );\n    }\n\n    const [from, to] = vertexElements;\n    edges.add(from.trim(), to.trim());\n  }\n\n  return edges;\n}\n\nexport function parseCoverSize(coverSizeRepr: string) {\n  const coverSize = parseInt(coverSizeRepr.trim());\n\n  if (isNaN(coverSize)) {\n    throw new Error(`Unable to parse cover size \"${coverSize}\" as an integer`);\n  }\n\n  return coverSize;\n}\n","import { IEdge } from \"./Edge\";\nimport { INode } from \"./Node\";\n\nexport interface IGraph {\n  nodes: INode[];\n  edges: IEdge[];\n}\n\n/**\n * Class which represents an undirected Graph\n */\nexport default class Graph implements IGraph {\n  nodes: INode[] = [];\n  edges: IEdge[] = [];\n\n  addVertices(newVertices: INode[]) {\n    this.nodes = [...this.nodes, ...newVertices];\n  }\n\n  addEdges(newEdges: IEdge[]) {\n    this.edges = [...this.edges, ...newEdges];\n  }\n}\n","export interface IEdge {\n  from: string;\n  to: string;\n}\n\n/**\n * Class which represents an undirected graph edge.\n */\nexport default class Edge implements IEdge {\n  from: string;\n  to: string;\n\n  constructor(from: string, to: string) {\n    this.from = from;\n    this.to = to;\n  }\n}\n","import Edge, { IEdge } from \"./Edge\";\nimport Node, { INode } from \"./Node\";\n\n/**\n * Class which represents an edge gadget, a data structure\n * used in the transformation between Vertex Cover problem\n * instances to Hamiltonian Cycle problem instances.\n */\nexport default class EdgeGadget {\n  vertices: INode[];\n  edges: IEdge[];\n  edgeGadgetID: string;\n\n  leftSideVertexID: string;\n  isTopLeftVertexConnected: boolean = false;\n  isBottomLeftVertexConnected: boolean = false;\n\n  rightSideVertexID: string;\n  isTopRightVertexConnected: boolean = false;\n  isBottomRightVertexConnected: boolean = false;\n\n  static VERTEX_IN_EDGE_GADGET: number = 12;\n\n  constructor(leftVertexID: string, rightVertexID: string) {\n    this.leftSideVertexID = leftVertexID;\n    this.rightSideVertexID = rightVertexID;\n    this.edgeGadgetID = leftVertexID + \"-\" + rightVertexID;\n\n    this.vertices = [];\n    for (let i = 1; i <= EdgeGadget.VERTEX_IN_EDGE_GADGET; ++i) {\n      this.vertices.push(new Node(this.edgeGadgetID + \"-\" + i));\n    }\n\n    this.edges = [];\n    for (let i = 0; i < this.vertices.length - 1; ++i) {\n      if (i === 5) continue;\n      this.edges.push(new Edge(this.vertices[i].id, this.vertices[i + 1].id));\n    }\n    this.edges.push(new Edge(this.vertices[0].id, this.vertices[8].id));\n    this.edges.push(new Edge(this.vertices[2].id, this.vertices[6].id));\n    this.edges.push(new Edge(this.vertices[3].id, this.vertices[11].id));\n    this.edges.push(new Edge(this.vertices[5].id, this.vertices[9].id));\n  }\n\n  public static connectEdgeGadgets(\n    edgeGadgets: EdgeGadget[],\n    vertexID: string\n  ): Edge[] {\n    if (edgeGadgets.length < 2) {\n      return [];\n    }\n\n    const newEdges: IEdge[] = [];\n    for (let i = 0; i < edgeGadgets.length - 1; ++i) {\n      const firstGadget = edgeGadgets[i];\n      const secondGadget = edgeGadgets[i + 1];\n      let firstId = \"\";\n      let secondId = \"\";\n\n      if (vertexID === firstGadget.leftSideVertexID) {\n        firstId = firstGadget.vertices[5].id;\n        firstGadget.isBottomLeftVertexConnected = true;\n      } else {\n        firstId = firstGadget.vertices[11].id;\n        firstGadget.isBottomRightVertexConnected = true;\n      }\n      if (vertexID === secondGadget.leftSideVertexID) {\n        secondId = secondGadget.vertices[0].id;\n        secondGadget.isTopLeftVertexConnected = true;\n      } else {\n        secondId = secondGadget.vertices[6].id;\n        secondGadget.isTopRightVertexConnected = true;\n      }\n\n      newEdges.push(new Edge(firstId, secondId));\n    }\n\n    return newEdges;\n  }\n\n  public static connectEdgeGadgetWithSelectors(\n    edgeGadget: EdgeGadget,\n    selectors: INode[]\n  ): Edge[] {\n    const newEdges: Edge[] = [];\n\n    const connectionPoints: string[] = [];\n    if (!edgeGadget.isTopLeftVertexConnected) {\n      edgeGadget.isTopLeftVertexConnected = true;\n      connectionPoints.push(edgeGadget.vertices[0].id);\n    }\n    if (!edgeGadget.isBottomLeftVertexConnected) {\n      edgeGadget.isBottomLeftVertexConnected = true;\n      connectionPoints.push(edgeGadget.vertices[5].id);\n    }\n    if (!edgeGadget.isTopRightVertexConnected) {\n      edgeGadget.isTopRightVertexConnected = true;\n      connectionPoints.push(edgeGadget.vertices[6].id);\n    }\n    if (!edgeGadget.isBottomRightVertexConnected) {\n      edgeGadget.isBottomRightVertexConnected = true;\n      connectionPoints.push(edgeGadget.vertices[11].id);\n    }\n\n    selectors.forEach(({ id }) => {\n      connectionPoints.forEach(identifier => {\n        newEdges.push(new Edge(id, identifier));\n      });\n    });\n\n    return newEdges;\n  }\n}\n","import React, { PureComponent } from \"react\";\nimport \"./index.scss\";\n\ninterface Props {\n  tabNames: string[];\n  children: any[];\n}\n\ninterface State {\n  currentTab: number;\n}\n\nexport default class Tabs extends PureComponent<Props, State> {\n  state = {\n    currentTab: 0\n  };\n\n  render() {\n    const { tabNames, children } = this.props;\n    const { currentTab } = this.state;\n\n    return (\n      <div className=\"Tabs\">\n        <ul className=\"Tabs__tab-list\">\n          {tabNames.map((name, i) => (\n            <li\n              key={i}\n              className={\n                \"tab-list__tab-item\" + (i === currentTab ? \" active\" : \"\")\n              }\n            >\n              <button onClick={() => this.setState(() => ({ currentTab: i }))}>\n                {name}\n              </button>\n            </li>\n          ))}\n        </ul>\n        <div className=\"Tabs__tab-container\">\n          {React.Children.map(children, (child, index) =>\n            index === currentTab ? child : <div hidden>{child}</div>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport \"./App.scss\";\nimport Graph from \"react-graph-vis\";\nimport SubmittableTextarea from \"./components/SubmittableTextarea\";\nimport { vertexCoverInstanceParser } from \"./lib/vertexCoverInstanceParser\";\nimport { IGraph } from \"./lib/Graph\";\nimport transformation from \"./lib/transformation\";\nimport Tabs from \"./components/Tabs\";\n\nconst graphOptions = {\n  layout: {\n    hierarchical: false,\n    randomSeed: 0\n  },\n  edges: {\n    color: \"#000000\",\n    arrows: {\n      to: {\n        enabled: false\n      }\n    }\n  },\n  physics: {\n    enabled: false\n  }\n};\n\ninterface State {\n  instances: {\n    vcGraph: IGraph;\n    hcGraph: IGraph;\n  }[];\n}\n\nclass App extends Component<{}, State> {\n  state: State = {\n    instances: []\n  };\n\n  onNewProblemInstance = (value: string): boolean => {\n    try {\n      const vcInstance = vertexCoverInstanceParser(value);\n      const hcInstance = transformation(vcInstance);\n\n      console.log({ value, vcInstance, hcInstance });\n\n      this.setState(({ instances }) => ({\n        instances: instances.concat({\n          vcGraph: vcInstance.graph,\n          hcGraph: hcInstance\n        })\n      }));\n    } catch (error) {\n      console.error(error);\n    }\n    return false;\n  };\n\n  render() {\n    return (\n      <div className=\"container\">\n        <SubmittableTextarea onSubmit={this.onNewProblemInstance} />\n        {this.state.instances.map(({ vcGraph, hcGraph }, index) => (\n          <Tabs\n            key={index}\n            tabNames={[\"Vertex Cover Graph\", \"Hamiltonian Circuit Graph\"]}\n          >\n            <div className=\"graph-container\">\n              <Graph graph={vcGraph} options={graphOptions} />\n            </div>\n            <div className=\"graph-container\">\n              <Graph graph={hcGraph} options={graphOptions} />\n            </div>\n          </Tabs>\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import Graph, { IGraph } from \"./Graph\";\nimport Node, { INode, mapToGroupedNodes } from \"./Node\";\nimport EdgeGadget from \"./EdgeGadget\";\nimport { IVertexCoverInstance } from \"./IVertexCoverInstance\";\n\n/**\n * Method to transform in polynomial time instances of the Vertex\n * Cover problem to instances of the Hamiltonian Cycle problem.\n */\nexport default function transformation({\n  graph,\n  coverSize\n}: IVertexCoverInstance): IGraph {\n  const newGraph = new Graph();\n\n  // Selectors creation\n  const selectors: INode[] = [];\n  for (let i = 1; i <= coverSize; ++i) {\n    selectors.push(new Node(\"Selector-\" + i));\n  }\n  newGraph.addVertices(mapToGroupedNodes(selectors, 0));\n\n  // Edge gadgets creation\n  const edgeGadgets: EdgeGadget[] = [];\n  const vertexAndEdgeGadgetsInfo = new Map<string, EdgeGadget[]>();\n  graph.nodes.forEach(({ id }) => vertexAndEdgeGadgetsInfo.set(id, []));\n\n  graph.edges.forEach(({ from, to }) => {\n    const newEdgeGadget = new EdgeGadget(from, to);\n    const firstVertexEdgeGadgets = vertexAndEdgeGadgetsInfo.get(from);\n    const secondVertexEdgeGadgets = vertexAndEdgeGadgetsInfo.get(to);\n\n    if (!firstVertexEdgeGadgets || !secondVertexEdgeGadgets) {\n      throw new Error(\n        \"Each graph vertex should have an EdgeGadget array initialized\"\n      );\n    }\n    firstVertexEdgeGadgets.push(newEdgeGadget);\n    secondVertexEdgeGadgets.push(newEdgeGadget);\n    edgeGadgets.push(newEdgeGadget);\n  });\n\n  edgeGadgets.forEach(({ vertices, edges }, i) => {\n    newGraph.addVertices(mapToGroupedNodes(vertices, (i + 1) * 3));\n    newGraph.addEdges(edges);\n  });\n\n  // Connections between edge gadgets\n  graph.nodes.forEach(({ id }) => {\n    const edgeGadgets = vertexAndEdgeGadgetsInfo.get(id);\n    if (!edgeGadgets) {\n      throw new Error(\n        \"Each graph vertex should have an EdgeGadget array initialized\"\n      );\n    }\n    newGraph.addEdges(EdgeGadget.connectEdgeGadgets(edgeGadgets, id));\n  });\n\n  // Connections between edge gadgets and selectors\n  edgeGadgets.forEach(edgeGadget =>\n    newGraph.addEdges(\n      EdgeGadget.connectEdgeGadgetWithSelectors(edgeGadget, selectors)\n    )\n  );\n\n  return newGraph;\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.scss\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}